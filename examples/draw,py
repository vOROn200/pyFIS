#!/usr/bin/env python3
"""
Send FLIPDOT column data from a text file using the LAWO MONO protocol.

The script:
  - Opens a serial MONO master (lawo.SerialMONOMaster).
  - Sends a QUERY command.
  - Sends PRE_BITMAP_FLIPDOT with configured width/height bytes.
  - Reads a payload text file; each non-empty, non-comment line is parsed
    into a list of bytes and sent as CMD_COLUMN_DATA_FLIPDOT.
  - Optionally sends a final QUERY.

Text file format (payloads):

  - Encoding: UTF-8.
  - Lines starting with '#' or empty lines are ignored.
  - Everything after '#' in a line is treated as a comment and ignored.
  - Remaining text in a line is a list of payload bytes, including
    the leading column index byte.
  - Bytes can be written as:
        0x08, 0x90, 0x40, ...
        08 90 40 ...
    i.e. with or without '0x' prefix; values are parsed as hexadecimal.
  - Separators: comma and/or whitespace in any combination.

Example line:

    0x08, 0x90,0x40,0x81,0x08,0x20,0x01, 0x90,0x28,0x00,0x06,0x80,0x00

This becomes payload:

    [0x08, 0x90, 0x40, 0x81, 0x08, 0x20, 0x01, 0x90, 0x28, 0x00, 0x06, 0x80, 0x00]
"""

import argparse
import time
from typing import List, Tuple

from lawo import SerialMONOMaster

DEFAULT_DISPLAY_ADDRESS = 0x05
DEFAULT_COMMAND_DELAY = 0.2


def parse_hex_payload_file(path: str) -> List[Tuple[int, list]]:
    """
    Parse a payload text file into a list of (lineno, payload_bytes).

    File format:
      - UTF-8 text.
      - Empty lines and lines starting with '#' are ignored.
      - Inline comments starting with '#' are removed.
      - Remaining text is split on ',' and whitespace into tokens.
      - Each token is parsed as a hexadecimal byte (0x.. or ..).
    """
    payloads: List[Tuple[int, list]] = []

    with open(path, "r", encoding="utf-8") as f:
        for lineno, raw_line in enumerate(f, start=1):
            line = raw_line.strip()
            if not line or line.startswith("#"):
                continue

            # Strip inline comment
            if "#" in line:
                line = line.split("#", 1)[0].strip()
                if not line:
                    continue

            # Normalize delimiters: comma -> space
            line = line.replace(",", " ")
            tokens = [t for t in line.split() if t]

            if not tokens:
                continue

            bytes_line: List[int] = []
            bad_token = False

            for tok in tokens:
                tok_stripped = tok.strip()
                try:
                    if tok_stripped.lower().startswith("0x"):
                        val = int(tok_stripped, 16)
                    else:
                        # still interpret as hex
                        val = int(tok_stripped, 16)
                except ValueError:
                    print(
                        f"Warning: invalid token '{tok_stripped}' "
                        f"on line {lineno}, skipping this line"
                    )
                    bad_token = True
                    break

                bytes_line.append(val & 0xFF)

            if bad_token or not bytes_line:
                continue

            payloads.append((lineno, bytes_line))

    return payloads


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Send FLIPDOT column data from a payload text file "
        "via LAWO MONO protocol."
    )
    parser.add_argument(
        "--port",
        default="COM3",
        help="Serial port (default: COM3)",
    )
    parser.add_argument(
        "--baudrate",
        type=int,
        default=19200,
        help="Serial baudrate (default: 19200)",
    )
    parser.add_argument(
        "--display-address",
        type=lambda v: int(v, 0),
        default=DEFAULT_DISPLAY_ADDRESS,
        help="MONO bus display address in hex or decimal "
        "(default: 0x5)",
    )
    parser.add_argument(
        "--file",
        required=True,
        help="Path to the payload text file.",
    )
    parser.add_argument(
        "--delay",
        type=float,
        default=DEFAULT_COMMAND_DELAY,
        help="Delay between commands in seconds (default: 0.2)",
    )
    parser.add_argument(
        "--pre-width",
        type=lambda v: int(v, 0),
        default=0x08,
        help="PRE_BITMAP_FLIPDOT width byte (default: 0x08)",
    )
    parser.add_argument(
        "--pre-height",
        type=lambda v: int(v, 0),
        default=0x04,
        help="PRE_BITMAP_FLIPDOT height byte (default: 0x04)",
    )
    parser.add_argument(
        "--no-final-query",
        action="store_true",
        help="Do not send the final QUERY command at the end.",
    )

    args = parser.parse_args()

    display_address = args.display_address

    print(
        f"Opening MONO bus on {args.port} @ {args.baudrate} baud, "
        f"display address 0x{display_address:X}"
    )

    bus = SerialMONOMaster(
        port=args.port,
        baudrate=args.baudrate,
        stopbits=2,
        debug=True,
    )

    # Initial QUERY
    print("Sending initial QUERY...")
    bus.send_command(display_address, bus.CMD_QUERY, [])
    time.sleep(args.delay)

    # PRE-BITMAP (configure panel size / mode)
    pre_payload = [args.pre_width & 0xFF, args.pre_height & 0xFF]
    print(f"Sending PRE_BITMAP_FLIPDOT: {pre_payload}")
    bus.send_command(
        display_address,
        bus.CMD_PRE_BITMAP_FLIPDOT,
        pre_payload,
    )
    time.sleep(args.delay)

    # Load payloads from file
    payloads = parse_hex_payload_file(args.file)
    if not payloads:
        print("No payload lines found in file, nothing to send.")
        return

    print(f"Loaded {len(payloads)} payload(s) from '{args.file}'.")

    # Send each payload as a CMD_COLUMN_DATA_FLIPDOT
    for lineno, payload in payloads:
        print(
            f"Sending COLUMN_DATA from line {lineno}: "
            f"{[f'0x{b:02X}' for b in payload]}"
        )
        bus.send_command(
            display_address,
            bus.CMD_COLUMN_DATA_FLIPDOT,
            payload,
        )
        time.sleep(args.delay)

    # Optional final QUERY
    if not args.no_final_query:
        print("Sending final QUERY...")
        bus.send_command(display_address, bus.CMD_QUERY, [])

    print("Done.")


if __name__ == "__main__":
    main()
